# <center>人工智能导论</center>
> 我们期末考试的题型主要包括了**选择、填空、判断、问答、证明**等题型。大家复习的时候需要多理解老师们在课上讲的关于传统人工智能、博弈论、新人工智能的部分中的**示例**，不需要死记硬背一些概念。其中博弈论部分复习要点为： 
> 1.**基本概念 博弈 占优策略 纳什均衡 （混合)策略 囚徒困境**
> 2.**对抗算法基本原理 minimax算法 alpha-beta剪枝 蒙特卡洛树搜索算法**
## 人工智能的概念
- #### 定义 智能机器
  能够在各类环境中自主地或交互地执行各种**拟人任务**(anthropomorphic tasks)的机器。
- #### 定义1 人工智能
  AI是关于知识的科学，怎样**表示知识**以及怎样**获得知识**并**使用知识**的科学。(Nilsson)
  AI就是研究如何使计算机做过去**只有人才能做**的智能工作。(Winston)
- #### 定义2 人工智能(学科)
  人工智能(学科)是计算机科学中涉及研究、设计和应用智能机器的一个分支。它的近期主要目标在于研究用机器来**模仿和执行人脑的某些智力功能**，并开发相关理论和技术。
- #### 定义3人工智能(能力)
  人工智能(能力)是智能机器所执行的通常与**人类智能有关的智能行为**，如判断、推理、证明、识别、感知、理解、通信、设计、思考、规划、学习和问题求解等思维活动。
- #### 定义4 
  人工智能是一种**使计算机能够思维**，使机器具有智力的激动人心的新尝试(Haugeland,1985)。
- #### 定义5 
  人工智能是那些与人的思维、决策、问题求解和学习等有关**活动的自动化**(Bellman,1978)。
- #### 定义6 
  人工智能是用计算模型研究智力行为 (Charniak和McDermott,1985)。
- #### 定义7 
  人工智能是研究那些使理解、推理和行为成为可能的计算(Winston,1992)。
- #### 定义8
  人工智能是一种能够执行需要人的智能的创造性机器的技术（Kurzwell,1990)。
- #### 定义9
- 人工智能研究如何使计算机做事让人过得更好（Rick和Knight,1991)。
- #### 定义10
  人工智能是一门通过计算过程力图**理解和模仿智能行为**的学科（Schalkoff,1990)。
- #### 定义11
  人工智能是计算机科学中与智能行为的自动化有关的一个分支（Luger和Stubblefield,1993)。

> 定义4和定义5涉及**拟人思维**；
> 定义6和定义7与**理性思维**有关；
> 定义8和定义9涉及**拟人行为**；
> 定义10和定义11与**拟人理性行为**有关。

<span style="color: red;">AI研究如何用计算机来**表示和执行**人类的**智能活动**，以**模拟**人脑所从事的推理、学习、思考和规划等**思维活动**，并**解决**需要人类的智力才能处理的**复杂问题**等。AI还涉及到脑科学、神经生理学、心理学、语言学、逻辑学、认知科学等许多学科领域。是一门综合性的交叉科学和边缘学科。</span>

> 不属于人工智能：
> - 自动控制类
> - 科学计算类
> - 固定了算法的
#### 强人工智能 *VS* 弱人工智能
- 弱人工智能: 某方面人工智能 强
- 强人工智能: 综合的多方面的人工智能 弱
#### 人工智能的潜力和界限
- 机器的智能：不管什么计算机，都等价于**图灵机**
- 人的智能：还远远没有认识清楚
#### 图灵机
- 一台图灵机是是一个数学概念，一个七元**有序**组
    | 纸带 | 符号 | 读写头 | 规则 | 状态 | 起始 | 结束 |
    | ---- | ---- | ------ | ---- | ---- | ---- | ---- |
    | 存储 | 符号 | 读写   | 程序 | 数据 | 开始 | 结束 |
- ##### 停机问题：判断任意一个程序是否能在有限的时间之内结束运行的问题
  - 就是判断任意一个程序是否能在有限的时间之内结束运行的问题
  - 等价于是否存在一个程序P，对于任意输入的程序w，能够判断w会在**有限时间内结束**或者**死循环**。
    ```python
    def halt(func, input):
        '''判定函数func在输入input下是否能结束/停机'''
        if func(input): return True
        else: return False
    def Turing(func):
        '''返回函数func在输入自己时是否能结束/停机的逆向结果'''
        if halt(func, func): return False
        else: return True
    if Turing(Turing) == True:
    ==> halt(Turing, Turing) == False
    ==> Turing(Turing) == False
    else Turing(Turing) == True:
    ==> halt(Turing, Turing) == False
    ==> Turing(Turing) == False
    ```
#### 哥德尔不完备定理
- 任何**包含自然数定义的形式系统**都是不完全的，也就是存在不能证明为真，也不能证明为假的命题
#### 可计算性
- 一个语言$L$是可以被图灵机所枚举（**enumerate**)的，如果存在一个图灵机$M$，使得输入是$L$中的串时，M输出“接受”；而对非$L$中的串，$M$输出“拒绝”或不停机
- 存在语言$L_d$，是不能被图灵机所枚举的，以及存在语言$L_u$，是不能被图灵机所决定的
## 人工智能的三大流派
#### 符号主义：最经典、接受程度最高的人工智能
- 把现实的物，映射到代表它的符号，在符号上完成所有的推理、计算等等，如**图灵测试**
#### 连接主义：新人工智能最红火的部分
- **神经网络**模型，模拟人脑神经元之间的连接，从而模拟出人脑的功能
- **深度学习**的功能强大，问题也不少
#### 行为主义：智能来自更低级的感知和行动
- 波士顿动力公司的机器狗、无人机、群体智能
## 人工智能的三个阶段
#### 早期人工智能：1956年创立到80年代早期
- 科技贵族的专属品
- 概念、机器定理证明，博弈，机器翻译，模式识别……
- **摩尔定律**：<span style="color: red;">当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上</span>
#### 中期的人工智能：80年代到2010年
- 以**专家系统**为代表的，以**知识**为核心
- 偏向控制，介于**自动化和计算机**之间
#### 新人工智能：近几年开始
- 介于**计算机**和**软件**之间

<font color="gray">

## 人工智能的三次浪潮
#### 20世纪50年代末至70年代初
人工智能学科诞生，基于知识的方法和具有初步智能的机器出现。
由于数学模型存在缺陷，以及计算能力无法完成复杂度呈指数级增长的计算任务，使人工智能发展陷入低谷。
#### 20世纪80年代初至90年代初
数学模型实现了重大突破，诞生了多层神经网络、BP反向传播算法和高度智能机器等。
由于人工智能计算机的成本与维护难度都较高，限制了其大规模商业应用和普及，使人工智能再次步入低谷。
#### 21世纪初至今
大数据、算法模型和计算能力的多重突破共同驱动了新一代人工智能的快速发展，尤其是2006年深度学习神经网络的提出，使人工智能的性能获得突破性进展，标志着人工智能迎来第三次高速成长期。

</font>

#### 新一代人工智能技术的新特点：人机融合，大数据，群体性，自主化，跨媒体

<font color="red">

#### 新一代人工智能与前两轮浪潮的本质区别
- 已经可以**大规模应用于经济社会实践**，给企业带来盈利，给社会管理带来实质性改善。
- 从**学术驱动、研究驱动**转变为**需求驱动和产业驱动**， 企业的研发激励巨大、引领作用显著；
- **企业投资**及**研发主导、政府规划引领**，使新一代人工智能发展正进入良性循环；前两次浪潮中主要依赖**政府资助**。

</font>

## 人工智能的领域
#### 常见的应用领域
- 机器定理证明(早期很红火，证明了四色定理)
- 博弈：人工智能的经典问题
  - **Alpha GO 成为新人工智能的标志事件**，从Alpha Go到Alpha Go Zero到Alpha Zero
- 模式识别：声图文
  - 视频图像（目标跟踪、视频理解、检索等等)
  - 静态图像（人脸识别、图像理解、检索等等)
  - 声音识别（内容识别、声纹识别、语音矫正、语音合成、检索等)
  - 文字识别（手写、联机手写、印刷体、多语种等等)
- 自然语言处理（很多方向)
  - 翻译、理解、问答、作文作诗
  - 翻译是最复杂，有规则学派和统计学派
- 数据挖掘和知识发现（当年曾经号称发现了开普洛行星运行定律)
- 专家系统（费肯鲍姆)
#### 自动程序设计
#### 机器人
#### NP-NPC问题
#### 群体智能
#### 智能+
  - 教育、网络、CAD、绘画、作曲、决策、模拟......
#### 从研究方向的分类
- 知识表示（IF–then，框架，三元组，统计模型，HMM隐马尔可夫链)
- 推理方法（归结原理，Lisp语言，Prolog语言)
- 搜索技术
- 机器学习（发现规则，调整参数)
- 群智算法（简单智能间能否配合)
- 规划（机器人)
- 神经网络（自己发现规则)
- 图计算（用一个数代表一个节点)
---
## 大数据
#### 大数据的5V特点（IBM提出)
- Volume (大量)
- Velocity(高速)
- Variety(多样)
- Value(低价值密度)
- Veracity(真实性)
#### 大数据时代大量的使用相关性而不是因果性
#### 局部大数据和打通的大数据
#### 合法的大数据与非法大数据
---
## 专家系统与产生式
#### 专家系统（产生式系统)的组成三要素
1. 一个综合数据库——存放信息
2. 一组产生式规则——知识
    |    规则的一般形式     |       简写       |
    | :-------------------: | :--------------: |
    | IF <前提> THEN <结论> | <前提> —> <结论> |
    | IF <条件> THEN <行动> | <条件> —> <行动> |
3. 一个控制系统——规则的解释或执行程序（控制策略)（推理引擎)
<font color="red">

#### Example1 字符转换（六六六）
- 综合数据库：{x}，其中x为字符
- 规则集
  1. IF A∧B THEN C
  2. IF A∧C THEN D
  3. IF B∧C THEN G
  4. IF B∧E THEN F
  5. IF D THEN E
- 控制策略：顺序排队
- 初始条件：{A，B}
- 结束条件：F∈{x}
- 求解过程

|       数据库        | 可触发规则 | 被触发规则 |
| :-----------------: | :--------: | :--------: |
|        A，B         |    （1)    |    （1)    |
|       A，B，C       |  （2) (3)  |    （2)    |
|     A，B，C，D      |  （3) (5)  |    （3)    |
|    A，B，C，D，G    |    （5)    |    （5)    |
|  A，B，C，D，G，E   |    （4)    |    （4)    |
| A，B，C，D，G，E，F |            |            |
#### Example2 M-C问题 Missionaries and Cannibals
- 综合数据库：$(m, c, b)$，其中：$0 ≤ m, c ≤ 3, b ∈ {0, 1}$
- 规则集：
  1. $\bold{IF} (m, c, 1) \bold{AND} 1≤i+j≤2 \bold{THEN} (m-i, c-j, 0)$
  2. $\bold{IF} (m, c, 0) \bold{AND} 1≤i+j≤2 \bold{THEN} (m+i, c+j, 1)$
- 控制策略
- 初始状态：(3，3，1)
- 目标状态（结束状态）：(0，0，0)
- 求解过程

|       | M Go → | C Go → | M Come ← | C Come ← |
| :---: | :----: | :----: | :------: | :------: |
| 33 00 |        |   2    |          |    1     |
| 32 01 |        |   2    |          |    1     |
| 31 02 |   2    |        |    1     |    1     |
| 22 11 |   2    |        |          |    1     |
| 03 30 |        |   2    |          |    1     |
| 02 31 |        |   2    |          |          |
| 00 33 |        |        |          |          |
#### Example3 猴子摘香蕉问题
- 综合数据库：$(M, B, Box, On, H)$
  - M：猴子的位置
  - B：香蕉的位置
  - Box：箱子的位置
  - On=0：猴子在地板上
  - On=1：猴子在箱子上
  - H=0：猴子没有抓到香蕉
  - H=1：猴子抓到了香蕉
- 规则集：
  1. IF $(x, y, z, 0, 0)$ THEN $(w, y, z, 0, 0)$【猴子可移动】
  2. IF $(x, y, x, 0, 0)$ THEN $(z, y, z, 0, 0)$【猴子可以带同位置箱子动】
  3. IF $(x, y, x, 0, 0)$ THEN $(x, y, x, 1, 0)$【猴子可以爬上箱子】
  4. IF $(x, y, x, 1, 0)$ THEN $(x, y, x, 0, 0)$【猴子可以从箱子下来】
  5. IF $(x, x, x, 1, 0)$ THEN $(x, x, x, 1, 1)$【猴子、香蕉、箱子同一位置，且站在箱子上，可以摘香蕉】
- 控制策略
- 初始状态：$(c, a, b, 0, 0)$
- 结束状态：$(x1, x2, x3, x4, 1)$
- 求解过程
  $1. (x, y, z, 0, 0)$
  $2. (z, y, z, 0, 0)$
  $3. (y, y, y, 0, 0)$
  $4. (y, y, y, 1, 0)$
  $5. (y, y, y, 1, 1)$

</font>

#### 产生式系统的特点
- 数据驱动
- 知识的无序性
- 控制系统与问题无关
- 数据、知识和控制相互独立
#### 产生式系统的类型
- 正向、逆向、双向产生式系统
- 可交换的产生式系统
- 可分解的产生式系统
---
## 搜索策略
#### 产生式系统的搜索策略
-  内容：状态空间的搜索问题
-  搜索方式：
   - 盲目搜索
   - 启发式搜索
-  关键问题：如何利用知识，尽可能有效地找到问题的解（最佳解）
#### 回溯策略（皇后问题）
<font color=red>

- $Example4$ 递归回溯的例子
```cpp
int ListLenght(LIST *pList)
{
    if (pList == NULL) return 0;
    else return ListLength(pList->next) + 1;
}
```
```cpp
procedure bt(c) is
    if reject(P, c) then return
    if accept(P, c) then output(P, c)
    s ← first(P, c)
    while s ≠ NULL do
        bt(s)
        s ← next(P, s)
```
</font>

#### 图搜索策略
- 回溯搜索：只保留从初始状态到当前状态的一条路径。
- 图搜索：保留所有已经搜索过的路径。
    - 深度优先搜索 Depth First Search
      - 一般不能保证找到最优解
      - 当深度限制不合理时，可能找不到解
    - 宽度优先搜索 Breadth First Search
      - 当问题有解时，一定能找到解
      - 当问题为单位耗散值，且问题有解时，一定能找到最优解
    - 渐进式深度优先搜索方法
#### 启发式图搜索：利用知识来引导搜索，达到减少搜索范围，降低问题复杂度的目的
- 启发信息的强度
  - 强：降低搜索工作量，但可能导致找不到最优解
  - 弱：一般导致工作量加大，极限情况下变为盲目搜索，但可能可以找到最优解
- 基本思想：定义一个评价函数$f$，对当前的搜索状态进行评估，找出一个最有希望的节点来扩展
#### 启发式搜索算法$A$
- $f(n) = g(n) + h(n)$
  - $f(n)$：评价函数
  - $h(n)$：启发函数
- 在$A$算法中，如果满足条件：$h(n)≤h^*(n)$则$A$算法称为$A*$算法

        #### $A*$算法的性质
        - $A*$算法的假设：设$n_i、n_j$是任意两个节点，有：$C(n_i, n_j) > ε$其中ε为大于0的常数
        - $f^*(s) = f^*(t) = h^*(s) = g^*(t) = f^*(n)$
        - 其中$s$是初始节点，$t$是目标节点，$n$是$s$到$t$的最佳路径上的节点
        - 定理1：对有限图，如果从初始节点s到目标节点t有路径存在，则算法$A$一定成功结束
        - 定理2：对无限图，若从初始节点s到目标节点t有路径存在，则$A*$一定成功结束
        - 引理2.1: 对无限图，若有从初始节点$s$到目标节点t的路径， 则$A*$不结束时，在OPEN表中即使最小的一个$f$值也将增到任意大，或有$f(n)>f^*(s)$
        - 引理2.2：在$A*$结束前，必存在节点$n$，使得$f(n) ≤ f^*(s)$
            > 引理2.2证明：存在一个节点n，n在 最佳路径上。
            >     f(n) = g(n) + h(n)
            >      = g*(n)+h(n) ≤g*(n)+h*(n) = f*(n)
            >     = f*(s)
            > 得证。
        - 推论2.1：OPEN表上任一具有$f(n)<f*(s)$的节点$n$，最终都将被$A*$选作扩展的节点。
            > 推论2.1证明：由定理2，知A*一定结束，由A*的结束条件，OPEN表中f(t)最小时才结束。而f(t) ≥ f*(t) = f*(s) 所以f(n)<f*(s)的n，均被扩展。得证。
        - 定理3（可采纳定理）：
        - 若存在从初始节点$s$到目标节点t有路径，则$A*$必能找到最佳解结束
        - 可采纳性的证明：<font color="red">$由定理1、2知A*一定找到一条路径结束，设找到的路径s→ t不是最佳的(t为目标)，则:f(t) = g(t) > f*(s)；由引理2.2知结束前OPEN中存在f(n)≤f*(s)的节点n，所以f(n) ≤ f*(s) < f(t)，因此A*应选择n扩展，而不是t，与假设A*选择t结束矛盾，得证$
            </font>
        - 推论3.1：$A*$选作扩展的任一节点$n$，有$f(n)≤f^*(s)$。
            > 由引理2.2知在A*结束前，OPEN中存在节点n’， f(n’)≤f*(s)
            设此时A*选择n扩展。
            如果n=n’，则f(n)≤f*(s)，得证。
            如果n≠ n’，由于A*选择n扩展，而不是n’， 所以有f(n) ≤ f(n’)≤f*(s)。得证。
        - 定理4：如果h2(n) > h1(n) (目标节点除外)，则A1扩展的节点数≥A2扩展的节点数
        > 定理4证明：
        使用数学归纳法，对节点的深度进行归纳
        (1)当d(n)=0时，即只有一个节点，显然定理成立。
        (2)设d(n)≤k时定理成立。(归纳假设)
        (3)当d(n)=k+1时，用反证法。
        设存在一个深度为k+1的节点n，被A2扩展，但没有被 A1扩展。而由假设，A1扩展了n的父节点，即n已经被生 成了。因此当A1结束时，n将被保留在OPEN中。
        所以有:f1(n) ≥ f*(s)
        即:g1(n)+h1(n) ≥ f*(s)
        所以: h1(n) ≥ f*(s) - g1(n)
        另一方面，由于A2扩展了n，有f2(n) ≤ f*(s)
        即: h2(n) ≤ f*(s) – g2(n) (A)
        由于d(n)=k时，A2扩展的节点A1一定扩展，有
        g1(n) ≤ g2(n) (因为A2的路A1均走到了)
        所以:h1(n)≥f*(s)-g1(n)≥f*(s)–g2(n) (B)
        比较A、B两式，有 h1(n) ≥ h2(n) ，与定理条件矛 盾。故定理得证。
#### 博弈树搜索
- 博弈：双人，一人一步，双方信息完备，零和（一方的收益必然意味着另一方的损失，博弈各方的收益和损失相加的总和永远为0）
- 最小最大搜索(Minimax Search): 最小最大搜索是在对抗搜索中最为基本的一种让玩家来计算最优策略的方法.
•Alpha-Beta剪枝搜索(Pruning Search): 一种对最小最大搜索进行改进的算法，即在搜索过程中可剪除无需搜索的分支节点，且不影响搜索结果。